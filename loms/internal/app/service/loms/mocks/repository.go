// Code generated by mockery v2.30.16. DO NOT EDIT.

package mocks

import (
	context "context"
	domain "route256/loms/internal/app/domain"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

// AddOrder provides a mock function with given fields: ctx, userID, items
func (_m *Repository) AddOrder(ctx context.Context, userID int64, items []domain.OrderItem) (int64, error) {
	ret := _m.Called(ctx, userID, items)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, []domain.OrderItem) (int64, error)); ok {
		return rf(ctx, userID, items)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, []domain.OrderItem) int64); ok {
		r0 = rf(ctx, userID, items)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, []domain.OrderItem) error); ok {
		r1 = rf(ctx, userID, items)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelReserve provides a mock function with given fields: ctx, orderID
func (_m *Repository) CancelReserve(ctx context.Context, orderID int64) error {
	ret := _m.Called(ctx, orderID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, orderID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetOrdersToCleanUp provides a mock function with given fields: ctx, delta
func (_m *Repository) GetOrdersToCleanUp(ctx context.Context, delta time.Duration) ([]int64, error) {
	ret := _m.Called(ctx, delta)

	var r0 []int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) ([]int64, error)); ok {
		return rf(ctx, delta)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) []int64); ok {
		r0 = rf(ctx, delta)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = rf(ctx, delta)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStatus provides a mock function with given fields: ctx, orderID
func (_m *Repository) GetStatus(ctx context.Context, orderID int64) (domain.Status, error) {
	ret := _m.Called(ctx, orderID)

	var r0 domain.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (domain.Status, error)); ok {
		return rf(ctx, orderID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) domain.Status); ok {
		r0 = rf(ctx, orderID)
	} else {
		r0 = ret.Get(0).(domain.Status)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, orderID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStocks provides a mock function with given fields: ctx, sku
func (_m *Repository) GetStocks(ctx context.Context, sku uint32) ([]*domain.StockInfo, error) {
	ret := _m.Called(ctx, sku)

	var r0 []*domain.StockInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) ([]*domain.StockInfo, error)); ok {
		return rf(ctx, sku)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) []*domain.StockInfo); ok {
		r0 = rf(ctx, sku)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.StockInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, sku)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOrder provides a mock function with given fields: ctx, orderID
func (_m *Repository) ListOrder(ctx context.Context, orderID int64) (*domain.OrderInfo, error) {
	ret := _m.Called(ctx, orderID)

	var r0 *domain.OrderInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*domain.OrderInfo, error)); ok {
		return rf(ctx, orderID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *domain.OrderInfo); ok {
		r0 = rf(ctx, orderID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.OrderInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, orderID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarkAsSold provides a mock function with given fields: ctx, orderID
func (_m *Repository) MarkAsSold(ctx context.Context, orderID int64) error {
	ret := _m.Called(ctx, orderID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, orderID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReserveStocks provides a mock function with given fields: ctx, info
func (_m *Repository) ReserveStocks(ctx context.Context, info *domain.ReserveInfo) error {
	ret := _m.Called(ctx, info)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.ReserveInfo) error); ok {
		r0 = rf(ctx, info)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetStatus provides a mock function with given fields: ctx, orderID, status
func (_m *Repository) SetStatus(ctx context.Context, orderID int64, status domain.Status) error {
	ret := _m.Called(ctx, orderID, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, domain.Status) error); ok {
		r0 = rf(ctx, orderID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
